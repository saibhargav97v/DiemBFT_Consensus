import pickle
import os
from time import sleep
import logging

from leader_election import LeaderElection
from ledger import Ledger
from pacemaker import PaceMaker
from block_tree import BlockTree
from messages import TimeOutMsg, TimeoutInfo, TC, ProposalMsg
from mem_pool import MemPool
from safety import Safety

def obj_to_string(obj, extra='    '):
    return str(obj.__class__) + '\n' + '\n'.join(
        (extra + (str(item) + ' = ' +
                  (obj_to_string(obj.__dict__[item], extra + '    ') if hasattr(obj.__dict__[item], '__dict__') else str(
                      obj.__dict__[item])))
         for item in sorted(obj.__dict__)))

class Validator(process):

    def setup(id: int, validators: list, clients: list, public_keys: list, private_key, config_num, num_faulty):
        self.setup_logger(config_num, logging.INFO)
        logging.info("Setup started")
        self.exit_flag = False
        self.validators = validators
        self.clients = clients
        self.modules = {}                  # A dictionary which stores all the modules' references  # delta, 1 is a place holder
        self.modules["config"] = {}
        self.modules["config"]["id"] = id
        self.modules["config"]["nfaulty"] = num_faulty
        self.modules["config"]["config_num"] = config_num
        self.pace_maker_timer = 4
        self.modules['validators_list'] = self.validators 
        self.safety = Safety(self.modules, private_key, public_keys, -1, -1) # TODO Check this initialization
        self.block_tree = BlockTree(self.modules)
        self.mem_pool = MemPool(self.modules)
        self.ledger = Ledger(self.modules)
        self.pace_maker = PaceMaker(self.modules)
        self.leader_election = LeaderElection(self.modules, 5, 2)
        self.modules['ledger'] = self.ledger
        self.modules['pace_maker'] = self.pace_maker
        self.modules['block_tree'] = self.block_tree
        self.modules['leader_election'] = self.leader_election
        self.modules['safety'] = self.safety
        self.modules['mem_pool'] = self.mem_pool
        self.is_leader =  True if id == 0 else False
        self.sysinit = True
        self.has_pending_transactions = True
        self.modules['latest_committed_payload'] = None
        self.initalize_ledger_file(config_num)
        
    def setup_logger(config_num,log_level):
        if not os.path.exists(f"../logs/{config_num}"):
            os.makedirs(f"../logs/{config_num}")
        log_file = f"../logs/{config_num}/validator_{id}.log"
        logging.basicConfig(filename=log_file, filemode='w', level=log_level,
                            format='%(asctime)s %(levelname)-8s %(message)s', 
                            datefmt='%Y-%m-%d %H:%M:%S')


    def initalize_ledger_file(config_num):
        file_path = f"../ledgers/{config_num}/ledger_{str(self.modules['config']['id'])}.txt"
        if not os.path.exists(f"../ledgers/{config_num}"):
            os.makedirs(f"../ledgers/{config_num}")
        
        with open(file_path, 'w+') as f:
            pass


    def run():
        
        while not received(('done',)):
            output("Starting Timer in :", id)
            cur_round = self.pace_maker.current_round
            timer_duration = self.pace_maker.get_round_timer()
            output("Current Round", self.pace_maker.current_round, "in: ", id)
            
            if await(self.pace_maker.current_round == cur_round + 1):
                self.send_ack_to_client(self.modules['latest_committed_payload'])
                output("Round Progressed to ", self.pace_maker.current_round ,"No timeouts in id: ", id) 

            elif timeout(timer_duration):
                output("Round timed out after ", timer_duration, "in :", id)
                self.send_ack_to_client(self.modules['latest_committed_payload'])
                self.pacemaker_local_timeout_round()
        
        self.logging.info(f'Validator {id} Terminating')

    def send_ack_to_client(c_message):
        output('in send_ack_to_client ', self.ledger.committed_txns.keys(), "in :", id)
        if c_message:
            output('C_message', c_message, " : to client ", self.clients[int(c_message[1][1:])])
            send(('Ack', id, c_message[0], logical_clock(), c_message[3]), to=(self.clients[int(c_message[1][1:])]))
        self.modules['latest_committed_payload'] = None

    def receive(msg = (action, sender, msg, time, txn_id), from_=p):
        valid_msg = self.modules['safety'].verify_msg_signature(msg, sender)
        if valid_msg:
            msg = pickle.loads(msg.message)
            if action == "Client":
                output("From client : ", p, "Msg : ", msg)
                self.mem_pool.add_command_to_mempool([msg, sender, time, txn_id])
                # output(obj_to_string(self.mem_pool))
                if self.sysinit:
                    self.sysinit = False
                    self.process_new_round_event(self.pace_maker.last_round_tc)

    def receive(msg=(action, sender, msg, time), from_=p):
        valid_msg = True #self.modules['safety'].verify_msg_signature(msg, sender)
        if valid_msg:
            #msg = pickle.loads(msg.message)
            if action == 'Local Timeout':
                output('Local Timeout', msg)
            elif action == 'Propose':
                # output("Proposal received at Validator", self.modules["config"]["id"], "msg: ", obj_to_string(msg))
                self.process_proposal_message(msg)
            elif action == 'vote_message':
                self.process_vote_message(msg)
            elif action == 'Timeout':
                output('Timeout', msg)
                self.process_timeout_message(msg)
            else:
                output('Default')
        else:
            output('Bad signature')


    def process_certificate_qc(qc):
        self.block_tree.process_qc(qc)
        # self.modules["leader_election"].update_leaders(qc)
        self.pace_maker.advance_round_qc(qc)

    def setattr(attr,val):
        if attr == 'highest_vote_round': self.modules['safety'].set_highest_qc_round(val)
        elif attr == 'current_round': self.modules['pace_maker']['current_round'] = val

    def process_proposal_message(P):
        valid_msg = self.modules['safety'].verify_msg_signature(P.signature, P.sender)
        if not valid_msg:
            return
        self.process_certificate_qc(P.block.qc)
        self.process_certificate_qc(P.high_commit_qc)
        self.pace_maker.advance_round_tc(P.last_round_tc)
        round = self.modules["pace_maker"].current_round
        leader = self.modules["leader_election" ].get_leader(round)
        output("Propose here 1")
        if P.block.round != round or P.sender != leader or P.block.author != leader: #or not self.has_pending_transactions:
            output("No Progress at",self.modules["config"]["id"])
            return
        
        self.modules["block_tree"].execute_and_insert(P.block)

        # Logic to remove transaction from non-leader validator's mempool

        if P.block.payload is not None and len(P.block.payload) > 0:
            self.mem_pool.update_mempool(P.block.payload)
            # output("Mempool of validator", self.modules["config"]["id"], "after update: ", self.mem_pool.commands)
        

        vote_msg = self.modules["safety"].make_vote(P.block, P.last_round_tc)
        # if self.pace_maker.current_round == 2 and self.modules["config"]["id"] == 0: # basic timeout testing
        #     output("0 manual timeout trigger")
        #     sleep(3)
        #     return
        if vote_msg != None:
            next_leader = self.modules["leader_election"].get_leader(round+1)
            # send(('vote_message', id, self.modules["safety"].sign_message(vote_msg), logical_clock()), to=self.validators[next_leader])
            self.send_message('vote_message',vote_msg,next_leader)

    def process_timeout_message(M):
        output('Received Timeout at ', self.modules["config"]["id"], "with cur round = ", self.pace_maker.current_round)
        self.process_certificate_qc(M.tmo_info.high_qc)
        self.process_certificate_qc(M.high_commit_qc)
        self.modules["pace_maker"].advance_round_tc(M.last_round_tc)

        tc = self.pacemaker_process_remote_timeout(M)
        if tc != None:
            output('tc formed at :  ',self.modules["config"]["id"])
            self.modules["pace_maker"].advance_round_tc(tc)
            self.process_new_round_event(tc)

    def process_vote_message(vote_msg):
        valid_msg = self.modules['safety'].verify_msg_signature(vote_msg.signature, vote_msg.sender)
        if not valid_msg:
            return
        qc = self.modules["block_tree"].process_vote(vote_msg)
        if qc != None:
            # output('qc formed at :  ',self.modules["config"]["id"],  obj_to_string(qc))
            self.process_certificate_qc(qc)
            self.process_new_round_event(self.pace_maker.last_round_tc)
    
    def process_new_round_event(last_tc):
        if self.modules["config"]["id"] == self.modules["leader_election"].get_leader(self.modules["pace_maker"].current_round):
            next_txn = self.mem_pool.get_transaction()
            if next_txn is None:
                return
            block = self.modules["block_tree"].generate_block(self.modules["config"], next_txn, self.modules["pace_maker"].current_round)
            block.author = id
            # output("Validator", self.modules["config"]["id"], " Broadcasting Proposal Block: ", obj_to_string(block))
            signature = self.modules["safety"].sign_message(block.id)
            proposal_msg = ProposalMsg(block, last_tc, self.block_tree.high_commit_qc,id, signature)
            # send(('Propose', id, self.modules["safety"].sign_message(proposal_msg), logical_clock()), to=self.validators)
            self.send_message('Propose',proposal_msg,'broadcast')
        else :
            pass# output("I am not a leader", self.modules["config"]["id"])

    def send_message(msg_type, msg, dstn='broadcast'):
        if dstn =='broadcast':
            dstn = self.validators
        else:
            dstn = self.validators[dstn]

        send((msg_type, id, msg, logical_clock()), to = dstn) #self.modules["safety"].sign_message(msg)
    
    def pacemaker_local_timeout_round():
        timeout_info = self.safety.make_timeout(self.pace_maker.current_round, self.block_tree.high_qc, self.pace_maker.last_round_tc)    
        timeout_msg  = TimeOutMsg(timeout_info, self.pace_maker.last_round_tc, self.modules["block_tree"].high_commit_qc)
        output('Broadcasting Timeout at ', self.modules["config"]["id"], "at round : ", self.pace_maker.current_round)
        self.send_message('Timeout',timeout_msg,'broadcast')
    
    def pacemaker_process_remote_timeout(timeout_msg):
        tm_info = timeout_msg.tmo_info
        if tm_info.round < self.pace_maker.current_round:
            return None
        if self.pace_maker.pending_timeouts.get(tm_info.round, None) is None:
            self.pace_maker.pending_timeouts[tm_info.round] = set()
        if self.pace_maker.pending_timeouts_high_qc_rounds.get(tm_info.round, None) is None:
            self.pace_maker.pending_timeouts_high_qc_rounds[tm_info.round] = set()
        if tm_info.sender not in self.pace_maker.pending_timeouts[tm_info.round]:
            self.pace_maker.pending_timeouts[tm_info.round].add(tm_info.sender)
            self.pace_maker.pending_timeouts_high_qc_rounds[tm_info.round].add(tm_info.high_qc.vote_info.round)
        if len(self.pace_maker.pending_timeouts[tm_info.round]) == self.modules["config"]["nfaulty"] + 1:
            self.pacemaker_local_timeout_round()
        if len(self.pace_maker.pending_timeouts[tm_info.round]) == 2*self.modules["config"]["nfaulty"] + 1:
            return TC(tm_info.round, self.pace_maker.pending_timeouts_high_qc_rounds[tm_info.round], self.pace_maker.pending_timeouts[tm_info.round])
        return None

