import pickle
import os
from time import sleep
import util
import logging

from leader_election import LeaderElection
from ledger import Ledger
from pacemaker import PaceMaker
from block_tree import BlockTree
from messages import TimeOutMsg, TimeoutInfo, TC, ProposalMsg
from mem_pool import MemPool
from safety import Safety

def obj_to_string(obj, extra='    '):
    return str(obj.__class__) + '\n' + '\n'.join(
        (extra + (str(item) + ' = ' +
                  (obj_to_string(obj.__dict__[item], extra + '    ') if hasattr(obj.__dict__[item], '__dict__') else str(
                      obj.__dict__[item])))
         for item in sorted(obj.__dict__)))

class Validator(process):

    def setup(id: int, validators: list, clients: list, public_keys: list, private_key, config_num):
        self.setup_logger(config_num, logging.INFO)
        logging.info("Setup started")
        self.exit_flag = False
        self.validators = validators
        self.clients = clients
        self.modules = {}                  # A dictionary which stores all the modules' references  # delta, 1 is a place holder
        self.modules["config"] = {}
        self.modules["config"]["id"] = id
        self.modules["config"]["nfaulty"] = 0
        self.modules["config"]["config_num"] = config_num
        self.pace_maker_timer = 4
        self.modules['validators_list'] = self.validators 
        self.safety = Safety(self.modules, private_key, public_keys, -1, -1) # TODO Check this initialization
        self.block_tree = BlockTree(self.modules)
        self.mem_pool = MemPool(self.modules)
        self.ledger = Ledger(self.modules)
        self.pace_maker = PaceMaker(self.modules)
        self.leader_election = LeaderElection(self.modules, 5, 2)
        self.modules['ledger'] = self.ledger
        self.modules['pace_maker'] = self.pace_maker
        self.modules['block_tree'] = self.block_tree
        self.modules['leader_election'] = self.leader_election
        self.modules['safety'] = self.safety
        self.modules['mem_pool'] = self.mem_pool
        self.is_leader =  True if id == 0 else False
        self.sysinit = True
        self.has_pending_transactions = True
        self.modules['latest_committed_payload'] = None
        self.initalize_ledger_file(config_num)
        
    def setup_logger(config_num,log_level):
        if not os.path.exists(f"../logs/{config_num}"):
            os.makedirs(f"../logs/{config_num}")
        log_file = f"../logs/{config_num}/validator_{id}.log"
        logging.basicConfig(filename=log_file, filemode='w', level=log_level,
                            format='%(asctime)s %(levelname)-8s %(message)s', 
                            datefmt='%Y-%m-%d %H:%M:%S')


    def initalize_ledger_file(config_num):
        file_path = f"../ledgers/{config_num}/ledger_{str(self.modules['config']['id'])}.txt"
        if not os.path.exists(f"../ledgers/{config_num}"):
            os.makedirs(f"../ledgers/{config_num}")
        
        with open(file_path, 'w+') as f:
            pass


    def run():
        
        while not self.exit_flag:
            if await(self.modules['latest_committed_payload'] is not None):
                payload = self.modules['latest_committed_payload']
                output('Payload : ', payload)
                send(('Ack', id, payload[0], logical_clock(), payload[3]), to=(self.clients[int(payload[1][1:])]))
                self.modules['latest_committed_payload'] = None
        # while not self.exit_flag:
        #     output("Starting Timer")
        #     cur_round = self.pace_maker.current_round
        #     timer_duration = self.pace_maker.get_round_timer()
        #     output("Current Round", self.pace_maker.current_round)
        #     if await(self.pace_maker.current_round == cur_round + 1):
        #         send_ack_to_client(self.modules['latest_committed_payload'])
        #         output("Round Progressed to ", self.pace_maker.current_round ,"No timeouts") 
        #         pass
        #     elif timeout(timer_duration):
        #         # send_ack_to_client(self.modules['latest_committed_payload'])
        #         output("Round timed out after ", timer_duration)
        #         timeout_info = self.safety.make_timeout(self.pace_maker.current_round, self.block_tree.high_qc, self.pace_maker.last_round_tc)    
        #         timeout_msg  = TimeOutMsg(timeout_info, self.pace_maker.last_round_tc, self.modules["block_tree"].high_commit_qc)
        #         send(('Timeout', timeout_msg), to=self.validators)


    # def send_ack_to_client(c_message):
    #     if c_message: pass
    #         send(('Ack', id, c_message[0], logical_clock(),c_message[3]), to=self.cur_client)
    #     self.modules['latest_committed_payload'] = None

    def receive(msg = (action, sender, msg, time, txn_id), from_=p):
        valid_msg = self.modules['safety'].verify_msg_signature(msg, sender)
        if valid_msg:
            message = pickle.loads(msg.message)
            if action == "Client":
                self.mem_pool.add_command_to_mempool([message, sender, time, txn_id])
                # output(obj_to_string(self.mem_pool))
                if self.sysinit:
                    self.sysinit = False
                    self.process_new_round_event(None)

    def receive(msg=(action, sender, msg, time), from_=p):
        valid_msg = True#self.modules['safety'].verify_msg_signature(msg, sender)
        if valid_msg:
            #msg = pickle.loads(msg.message)
            if action == 'Local Timeout':
                output('Local Timeout', msg)
            elif action == 'Propose':
                output("Proposal received at Validator", self.modules["config"]["id"], "msg: ", obj_to_string(msg))
                self.process_proposal_message(msg)
            elif action == 'vote_message':
                self.process_vote_message(msg)
            elif action == 'Timeout':
                output('Timeout', msg)
                self.process_timeout_message(msg)
            else:
                output('Default')
        else:
            output('Bad signature')


    def process_certificate_qc(qc):
        self.block_tree.process_qc(qc)
        # self.modules["leader_election"].update_leaders(qc)
        self.pace_maker.advance_round_qc(qc)

    def process_proposal_message(P):
        valid_msg = self.modules['safety'].verify_msg_signature(P.signature, P.sender)
        if not valid_msg:
            return
        self.process_certificate_qc(P.block.qc)
        self.process_certificate_qc(P.high_commit_qc)
        self.pace_maker.advance_round_tc(P.last_round_tc)
        round = self.modules["pace_maker"].current_round
        leader = self.modules["leader_election" ].get_leader(round)
        
        if P.block.round != round or P.sender != leader or P.block.author != leader: #or not self.has_pending_transactions:
            output("No Progress at",self.modules["config"]["id"])
            return
        
        self.modules["block_tree"].execute_and_insert(P.block)

        # Logic to remove transaction from non-leader validator's mempool

        if P.block.payload is not None and len(P.block.payload) > 0:
            self.mem_pool.update_mempool(P.block.payload)
            # output("Mempool of validator", self.modules["config"]["id"], "after update: ", self.mem_pool.commands)
        

        vote_msg = self.modules["safety"].make_vote(P.block, P.last_round_tc)
        if vote_msg != None:
            next_leader = self.modules["leader_election"].get_leader(round+1)
            send(('vote_message', id, vote_msg, logical_clock()), to=self.validators[next_leader])

    def process_timeout_message(M):
        self.process_certficate_qc(M.tmo_info.high_qc)
        self.process_certficate_qc(M.high_commit_qc)
        self.modules["pace_maker"].advance_round_tc(M.last_round_tc)
        tc = self.modules["pace_maker"].process_remote_timeout(M)
        if tc != None:
            self.modules["pace_maker"].advance_round(tc)
            self.process_new_round_event(None)

    def process_vote_message(vote_msg):
        valid_msg = self.modules['safety'].verify_msg_signature(vote_msg.signature, vote_msg.sender)
        if not valid_msg:
            return
        qc = self.modules["block_tree"].process_vote(vote_msg)
        if qc != None:
            output('qc formed at :  ',self.modules["config"]["id"],  obj_to_string(qc))
            self.process_certificate_qc(qc)
            self.process_new_round_event(None)
    
    def process_new_round_event(last_tc:None):
        if self.modules["config"]["id"] == self.modules["leader_election"].get_leader(self.modules["pace_maker"].current_round):
            next_txn = self.mem_pool.get_transaction()
            if next_txn is None:
                return
            block = self.modules["block_tree"].generate_block(self.modules["config"], next_txn, self.modules["pace_maker"].current_round)
            block.author = id
            output("Validator", self.modules["config"]["id"], " Broadcasting Proposal Block: ", obj_to_string(block))
            signature = self.modules["safety"].sign_message(block.id)
            proposal_msg = ProposalMsg(block, last_tc, self.block_tree.high_commit_qc,id, signature)
            send(('Propose', id, proposal_msg, logical_clock()), to=self.validators)
        else :
            pass# output("I am not a leader", self.modules["config"]["id"])
